// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: env_manager.proto

package envmanager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnvManageRPCClient is the client API for EnvManageRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnvManageRPCClient interface {
	Check(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
	CreateEnv(ctx context.Context, in *EnvSchema, opts ...grpc.CallOption) (*CreateReply, error)
	ResetEnv(ctx context.Context, opts ...grpc.CallOption) (EnvManageRPC_ResetEnvClient, error)
	StepEnv(ctx context.Context, opts ...grpc.CallOption) (EnvManageRPC_StepEnvClient, error)
	CloseEnv(ctx context.Context, in *Request, opts ...grpc.CallOption) (*CloseReply, error)
}

type envManageRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewEnvManageRPCClient(cc grpc.ClientConnInterface) EnvManageRPCClient {
	return &envManageRPCClient{cc}
}

func (c *envManageRPCClient) Check(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/manager.EnvManageRPC/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *envManageRPCClient) CreateEnv(ctx context.Context, in *EnvSchema, opts ...grpc.CallOption) (*CreateReply, error) {
	out := new(CreateReply)
	err := c.cc.Invoke(ctx, "/manager.EnvManageRPC/CreateEnv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *envManageRPCClient) ResetEnv(ctx context.Context, opts ...grpc.CallOption) (EnvManageRPC_ResetEnvClient, error) {
	stream, err := c.cc.NewStream(ctx, &EnvManageRPC_ServiceDesc.Streams[0], "/manager.EnvManageRPC/ResetEnv", opts...)
	if err != nil {
		return nil, err
	}
	x := &envManageRPCResetEnvClient{stream}
	return x, nil
}

type EnvManageRPC_ResetEnvClient interface {
	Send(*ResetRequest) error
	Recv() (*EnvReply, error)
	grpc.ClientStream
}

type envManageRPCResetEnvClient struct {
	grpc.ClientStream
}

func (x *envManageRPCResetEnvClient) Send(m *ResetRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *envManageRPCResetEnvClient) Recv() (*EnvReply, error) {
	m := new(EnvReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *envManageRPCClient) StepEnv(ctx context.Context, opts ...grpc.CallOption) (EnvManageRPC_StepEnvClient, error) {
	stream, err := c.cc.NewStream(ctx, &EnvManageRPC_ServiceDesc.Streams[1], "/manager.EnvManageRPC/StepEnv", opts...)
	if err != nil {
		return nil, err
	}
	x := &envManageRPCStepEnvClient{stream}
	return x, nil
}

type EnvManageRPC_StepEnvClient interface {
	Send(*AgentDecision) error
	Recv() (*EnvReply, error)
	grpc.ClientStream
}

type envManageRPCStepEnvClient struct {
	grpc.ClientStream
}

func (x *envManageRPCStepEnvClient) Send(m *AgentDecision) error {
	return x.ClientStream.SendMsg(m)
}

func (x *envManageRPCStepEnvClient) Recv() (*EnvReply, error) {
	m := new(EnvReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *envManageRPCClient) CloseEnv(ctx context.Context, in *Request, opts ...grpc.CallOption) (*CloseReply, error) {
	out := new(CloseReply)
	err := c.cc.Invoke(ctx, "/manager.EnvManageRPC/CloseEnv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnvManageRPCServer is the server API for EnvManageRPC service.
// All implementations must embed UnimplementedEnvManageRPCServer
// for forward compatibility
type EnvManageRPCServer interface {
	Check(context.Context, *Request) (*Reply, error)
	CreateEnv(context.Context, *EnvSchema) (*CreateReply, error)
	ResetEnv(EnvManageRPC_ResetEnvServer) error
	StepEnv(EnvManageRPC_StepEnvServer) error
	CloseEnv(context.Context, *Request) (*CloseReply, error)
	mustEmbedUnimplementedEnvManageRPCServer()
}

// UnimplementedEnvManageRPCServer must be embedded to have forward compatible implementations.
type UnimplementedEnvManageRPCServer struct {
}

func (UnimplementedEnvManageRPCServer) Check(context.Context, *Request) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedEnvManageRPCServer) CreateEnv(context.Context, *EnvSchema) (*CreateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEnv not implemented")
}
func (UnimplementedEnvManageRPCServer) ResetEnv(EnvManageRPC_ResetEnvServer) error {
	return status.Errorf(codes.Unimplemented, "method ResetEnv not implemented")
}
func (UnimplementedEnvManageRPCServer) StepEnv(EnvManageRPC_StepEnvServer) error {
	return status.Errorf(codes.Unimplemented, "method StepEnv not implemented")
}
func (UnimplementedEnvManageRPCServer) CloseEnv(context.Context, *Request) (*CloseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseEnv not implemented")
}
func (UnimplementedEnvManageRPCServer) mustEmbedUnimplementedEnvManageRPCServer() {}

// UnsafeEnvManageRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnvManageRPCServer will
// result in compilation errors.
type UnsafeEnvManageRPCServer interface {
	mustEmbedUnimplementedEnvManageRPCServer()
}

func RegisterEnvManageRPCServer(s grpc.ServiceRegistrar, srv EnvManageRPCServer) {
	s.RegisterService(&EnvManageRPC_ServiceDesc, srv)
}

func _EnvManageRPC_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnvManageRPCServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.EnvManageRPC/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnvManageRPCServer).Check(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnvManageRPC_CreateEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnvSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnvManageRPCServer).CreateEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.EnvManageRPC/CreateEnv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnvManageRPCServer).CreateEnv(ctx, req.(*EnvSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnvManageRPC_ResetEnv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EnvManageRPCServer).ResetEnv(&envManageRPCResetEnvServer{stream})
}

type EnvManageRPC_ResetEnvServer interface {
	Send(*EnvReply) error
	Recv() (*ResetRequest, error)
	grpc.ServerStream
}

type envManageRPCResetEnvServer struct {
	grpc.ServerStream
}

func (x *envManageRPCResetEnvServer) Send(m *EnvReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *envManageRPCResetEnvServer) Recv() (*ResetRequest, error) {
	m := new(ResetRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EnvManageRPC_StepEnv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EnvManageRPCServer).StepEnv(&envManageRPCStepEnvServer{stream})
}

type EnvManageRPC_StepEnvServer interface {
	Send(*EnvReply) error
	Recv() (*AgentDecision, error)
	grpc.ServerStream
}

type envManageRPCStepEnvServer struct {
	grpc.ServerStream
}

func (x *envManageRPCStepEnvServer) Send(m *EnvReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *envManageRPCStepEnvServer) Recv() (*AgentDecision, error) {
	m := new(AgentDecision)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EnvManageRPC_CloseEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnvManageRPCServer).CloseEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.EnvManageRPC/CloseEnv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnvManageRPCServer).CloseEnv(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// EnvManageRPC_ServiceDesc is the grpc.ServiceDesc for EnvManageRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnvManageRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manager.EnvManageRPC",
	HandlerType: (*EnvManageRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _EnvManageRPC_Check_Handler,
		},
		{
			MethodName: "CreateEnv",
			Handler:    _EnvManageRPC_CreateEnv_Handler,
		},
		{
			MethodName: "CloseEnv",
			Handler:    _EnvManageRPC_CloseEnv_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ResetEnv",
			Handler:       _EnvManageRPC_ResetEnv_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StepEnv",
			Handler:       _EnvManageRPC_StepEnv_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "env_manager.proto",
}

// DataBufferClient is the client API for DataBuffer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataBufferClient interface {
	Request(ctx context.Context, in *BlockDescription, opts ...grpc.CallOption) (*BlockReply, error)
	Step(ctx context.Context, opts ...grpc.CallOption) (DataBuffer_StepClient, error)
}

type dataBufferClient struct {
	cc grpc.ClientConnInterface
}

func NewDataBufferClient(cc grpc.ClientConnInterface) DataBufferClient {
	return &dataBufferClient{cc}
}

func (c *dataBufferClient) Request(ctx context.Context, in *BlockDescription, opts ...grpc.CallOption) (*BlockReply, error) {
	out := new(BlockReply)
	err := c.cc.Invoke(ctx, "/manager.DataBuffer/Request", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataBufferClient) Step(ctx context.Context, opts ...grpc.CallOption) (DataBuffer_StepClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataBuffer_ServiceDesc.Streams[0], "/manager.DataBuffer/Step", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBufferStepClient{stream}
	return x, nil
}

type DataBuffer_StepClient interface {
	Send(*AgentDecision) error
	CloseAndRecv() (*Reply, error)
	grpc.ClientStream
}

type dataBufferStepClient struct {
	grpc.ClientStream
}

func (x *dataBufferStepClient) Send(m *AgentDecision) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBufferStepClient) CloseAndRecv() (*Reply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Reply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DataBufferServer is the server API for DataBuffer service.
// All implementations must embed UnimplementedDataBufferServer
// for forward compatibility
type DataBufferServer interface {
	Request(context.Context, *BlockDescription) (*BlockReply, error)
	Step(DataBuffer_StepServer) error
	mustEmbedUnimplementedDataBufferServer()
}

// UnimplementedDataBufferServer must be embedded to have forward compatible implementations.
type UnimplementedDataBufferServer struct {
}

func (UnimplementedDataBufferServer) Request(context.Context, *BlockDescription) (*BlockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Request not implemented")
}
func (UnimplementedDataBufferServer) Step(DataBuffer_StepServer) error {
	return status.Errorf(codes.Unimplemented, "method Step not implemented")
}
func (UnimplementedDataBufferServer) mustEmbedUnimplementedDataBufferServer() {}

// UnsafeDataBufferServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataBufferServer will
// result in compilation errors.
type UnsafeDataBufferServer interface {
	mustEmbedUnimplementedDataBufferServer()
}

func RegisterDataBufferServer(s grpc.ServiceRegistrar, srv DataBufferServer) {
	s.RegisterService(&DataBuffer_ServiceDesc, srv)
}

func _DataBuffer_Request_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockDescription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataBufferServer).Request(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.DataBuffer/Request",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataBufferServer).Request(ctx, req.(*BlockDescription))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataBuffer_Step_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataBufferServer).Step(&dataBufferStepServer{stream})
}

type DataBuffer_StepServer interface {
	SendAndClose(*Reply) error
	Recv() (*AgentDecision, error)
	grpc.ServerStream
}

type dataBufferStepServer struct {
	grpc.ServerStream
}

func (x *dataBufferStepServer) SendAndClose(m *Reply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBufferStepServer) Recv() (*AgentDecision, error) {
	m := new(AgentDecision)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DataBuffer_ServiceDesc is the grpc.ServiceDesc for DataBuffer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataBuffer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manager.DataBuffer",
	HandlerType: (*DataBufferServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Request",
			Handler:    _DataBuffer_Request_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Step",
			Handler:       _DataBuffer_Step_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "env_manager.proto",
}
